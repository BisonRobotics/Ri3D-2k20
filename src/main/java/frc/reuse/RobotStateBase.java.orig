package frc.reuse;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import frc.reuse.math.geometry.Kinematics;
import frc.reuse.math.geometry.Pose2d;
import frc.reuse.math.geometry.Rotation2d;
import frc.reuse.math.geometry.Twist2d;
import frc.reuse.math.interpolation.InterpolatingDouble;
import frc.reuse.math.interpolation.InterpolatingTreeMap;
import frc.reuse.subsystems.vision.CoprocessorData;
import frc.reuse.subsystems.vision.CoprocessorData.VisionTargetInfo;
import frc.reuse.subsystems.vision.Point;
import frc.reuse.utilities.ConsoleLogger;
import frc.reuse.utilities.Reportable;

import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/** RobotStateBase provides global, formatted state of the robot for reuse subsystems
 * @author STEM Alliance of Fargo Moorhead
 * */
public abstract class RobotStateBase implements Reportable
{
    protected RobotStateBase()
    {
        // final Optional<VisionConfig> vc = EnhancedRobot.getConfig().vision;
        
        // kVisionEnabled = vc.isPresent();
        // if (kVisionEnabled)
        // {
        //     kCameraWidthDegrees = vc.get().kCameraWidthDegrees;
        // }
        // else
        // {
        //     kCameraWidthDegrees = 69.0;  // Microsoft livecam
        // }
        kCameraWidthDegrees = 0.0;
        kVisionEnabled = false;

        resetDriveState(0.0, new Pose2d());
        resetVisionState();
        resetRobotSpecificState();
    }

    public void reportState()
    {
        reportStateVision();
    }

    /** Reset all robot-specific state to its default values */
    protected abstract void resetRobotSpecificState();

    // --------------------------------------
    // ------------ Drive State -------------
    // --------------------------------------

    private static final int kObservationBufferSize = 100;

    private InterpolatingTreeMap<InterpolatingDouble, Pose2d> field_to_vehicle_;
    private double distance_driven_;
    private Twist2d vehicle_velocity_predicted_;
    private Twist2d vehicle_velocity_measured_;

    public synchronized void addFieldToVehicleObservation(double timestamp, Pose2d observation)
    {
        field_to_vehicle_.put(new InterpolatingDouble(timestamp), observation);
    }

    /** Process the latest drivetrain encoder data for odometry (estimate position of robot) */
    public synchronized void addRobotObservation(double timestamp, Twist2d measured_velocity, Twist2d predicted_velocity)
    {
        addFieldToVehicleObservation(timestamp, Kinematics.integrateForwardKinematics(getLatestFieldToVehicle().getValue(), measured_velocity));
        vehicle_velocity_measured_ = measured_velocity;
        vehicle_velocity_predicted_ = predicted_velocity;
    }

    /** Linear distance (hypotenuse) driven forwards by robot relative to when encoders last zeroed (inches) */
    public synchronized double getDistanceDriven()
    {
        return distance_driven_;
    }

    /** Returns the robot's position on the field at a certain time. Linearly interpolates between stored robot positions to fill in the gaps. */
    public synchronized Pose2d getFieldToVehicle(double timestamp) {
        return field_to_vehicle_.getInterpolated(new InterpolatingDouble(timestamp));
    }

    public synchronized Map.Entry<InterpolatingDouble, Pose2d> getLatestFieldToVehicle()
    {
        return field_to_vehicle_.lastEntry();
    }

    // public synchronized Twist2d getMeasuredVelocity()
    // {
    //     return vehicle_velocity_measured_;
    // }

    public synchronized Pose2d getPredictedFieldToVehicle(double lookahead_time)
    {
        return getLatestFieldToVehicle().getValue().transformBy(Pose2d.exp(vehicle_velocity_predicted_.scaled(lookahead_time)));
    }

    /** In inches per second */
    public synchronized Twist2d getPredictedVelocity()
    {
        return vehicle_velocity_predicted_;
    }

    public synchronized Twist2d getRobotOdometry(double left_encoder_delta_distance, double right_encoder_delta_distance, Rotation2d current_gyro_angle)
    {
        final Pose2d last_measurement = getLatestFieldToVehicle().getValue();
        final Twist2d delta = Kinematics.forwardKinematics(last_measurement.getRotation(), left_encoder_delta_distance, right_encoder_delta_distance, current_gyro_angle);
        distance_driven_ += delta.dx;
        return delta;
    }
        SmartDashboard.putNumber("Robot_Pose_X", odometry.getTranslation().x());
        SmartDashboard.putNumber("Robot_Pose_Y", odometry.getTranslation().y());
        SmartDashboard.putNumber("Robot_Pose_Theta", odometry.getRotation().getDegrees());
        // SmartDashboard.putNumber("Robot_Velocity", getMeasuredVelocity().dx);
        // SmartDashboard.putNumber("Distance Driven", getDistanceDriven());
    }

    /** Reset all drive state to its default values (robot stationary) */
    public synchronized void resetDriveState(double start_time, Pose2d initial_field_to_vehicle)
    {
        field_to_vehicle_ = new InterpolatingTreeMap<>(kObservationBufferSize);
        field_to_vehicle_.put(new InterpolatingDouble(start_time), initial_field_to_vehicle);
        vehicle_velocity_predicted_ = Twist2d.identity();
        vehicle_velocity_measured_ = Twist2d.identity();
        robotHeading = 0.0;
        distance_driven_ = 0.0;
    }

    public synchronized void resetDistanceDriven()
    {
        distance_driven_ = 0.0;
    }

    // --------------------------------------
    // ------------ Vision State ------------
    // --------------------------------------

    /** Robot has configured vision to be on */
    public final boolean kVisionEnabled;
    public final double kCameraWidthDegrees;

    protected List<Point> visionObservations = new ArrayList<Point>();
    /** Robot-specific criteria of if vision can see this target(s) */
    public boolean visionInView = false;

    /** Process the latest message from the coprocessor, updating the vision state of the robot */
    public synchronized void addVisionUpdate(Double time, CoprocessorData coprocessorData)
    {
        visionInView = coprocessorData.targets.size() > 0;
        if (!visionInView)
        {
            visionObservations.clear();
            return;
        }
        VisionTargetInfo largest = getLargestTarget(coprocessorData.targets);
        // TODO circular buffer trim if this gets too big
        visionObservations.add(0, (new Point(time, largest)));
    }

    public double getVisionError()
    {
        if (!visionInView && visionObservations.size() > 0)
        {
            return 0.0;
        }
        return visionObservations.get(0).getXError();
    }

    public synchronized double getExtrapolatedVisionError()
    {
        if (!visionInView && visionObservations.size() > 1)
        {
            return 0.0;
        }

        final Point errorBefore = visionObservations.get(1);
        final Point errorCurrent = visionObservations.get(0);
        final double now = Timer.getFPGATimestamp();
        return errorCurrent.extrapolate(errorBefore, now).getXError();
    }

    protected VisionTargetInfo getLargestTarget(List<VisionTargetInfo> targets)
    {
        if (targets.size() == 0)
        {
            ConsoleLogger.error("Shouldn't get largetest target in empty list");
        }

        VisionTargetInfo largestTarget = targets.get(0);
        for (VisionTargetInfo target : targets)
        {
            if (target.area() > largestTarget.area())
            {
                largestTarget = target;
            }
        }
        return largestTarget;
    }

    public boolean visionInView()
    {
        return visionInView;
    }

    protected void reportStateVision()
    {
        if (this.kVisionEnabled)
        {
            SmartDashboard.putBoolean("Targets In View", visionInView);
            if (visionInView)
            {
                SmartDashboard.putNumber("Vision Error", getVisionError());
            }
        }
    }

    /** Reset all vision state to its default values (does not see targets) */
    public synchronized void resetVisionState()
    {
        visionInView = false;
        visionObservations.clear();
    }
}
